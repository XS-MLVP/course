---
title: Callback Functions
description: Using Callbacks to Handle Circuit Events
categories: [Sample Projects, Tutorials]
tags: [examples, docs]
weight: 1
---
## Callbacks
### Overview
> Hardware description languages differ from high-level software programming languages like C++/Python. They have a unique "clock" characteristic. When using picker tools for verification, you may encounter situations where you want to trigger an operation on the rising edge of the clock. To achieve this, you need to use **callback functions**.

- A callback function is a function that is **passed as a parameter**.
- In the C language, callback functions can only be implemented using **function pointers**.
- In more modern programming languages like C++, Python, and ECMAScript, you can also use **functors or anonymous functions**.

A callback function is a function or procedure provided by the caller to be used by the callee. The typical usage is:
- **Method a() calls method b()**
- **After b() completes, it proactively calls the provided callback() method**

In the example below, we implement a simple callback. We define a method print_result for printing results, and a method add() for adding two numbers. After add completes, it calls the print_result() method to print the result.

```bash hl: title:
def add(x, y):
    return x + y

def sub(x, y):
    return x - y

def mul(x, y):
    return x * y

def div(x, y):
    return x / y

def calc(x, y, func):
    return func(x, y)

# Pass the function as a parameter and then call the function
print(calc(1, 2, add))
>>> 3
```

### Advantages of Callback Functions
Advantages
1. Callback functions help **separate code logic**, making the code more modular and maintainable.
2. They improve **reusability and flexibility**: Callback functions allow you to pass one function as a parameter to another function, enabling modular programming and enhancing code reusability and flexibility.
3. Decoupling: Callback functions can **decouple relationships** between different modules, making the code easier to maintain and extend.
4. Asynchronous execution: Callback functions can be executed after asynchronous operations are completed, avoiding thread blocking and improving application efficiency.

For example, in the following example, we define two callback functions addOne and addTwo to generate x+1 and x+2, respectively. We also define an intermediate function to generate reciprocals.

- We can use an intermediate function to call addOne and addTwo to generate numbers in the form of 1/(x+1) and 1/(x+2).
- We can also use an anonymous function to generate a number in the form of 1/(x+3).
```bash hl: title:

def addOne(x):
    return x + 1


def addTwo(x):
    return x + 2

from even import *

# Intermediate function
# Accepts a callback function as a parameter and returns its reciprocal
def getNumber(k, getEvenNumber):
    return 1 / getEvenNumber(k)

if __name__ == "__main__":
    x = 1
    # When we need to generate a number in the form of 1/(x+1)
    print(getNumber(x, addOne))
    # When we need a number in the form of 1/(x+2)
    print(getNumber(x, addTwo))
    # When we need a number in the form of 1/(x+3)
    print(getNumber(x, lambda k: k +3))

```
### Use Cases for Callback Functions

1. **Event Handling**: Callback functions can handle various events such as mouse clicks, keyboard input, and network requests.
2. **Asynchronous Operations**: Callback functions can be used for asynchronous operations like reading files, sending emails, and downloading files.
3. **Data Processing**: Callback functions can process data, such as sorting, filtering, and mapping arrays.

### Triggering Operations on the Rising Edge of the Clock Using Callback Functions

In the [test code](#test_random_generator_with_callback)below, we use callback functions to test a random number generator.

Throughout the test, we verify the random number generator's results over 114514 clock cycles and count the numbers generated greater than the median and those less than or equal to the median. Verification and data collection occur on the rising edge of the clock.

`TestRandomGenerator` is a class for testing the random number generator. Its attributes and methods include:

+ `self.dut` is an instance of `DUTRandomGenerator` used for testing.
+ `self.ref` is an instance of `LFSR_16` used for result verification.
+ `callback1(self, clk)` verifies the random number generator on the rising edge of the clock.
+ `callback2(self, clk)` counts the distribution of generated random numbers, also on the rising edge of the clock.
+ `test_rg(self, callback3)` method executes the entire test process and calls the `callback3` function at the end.

The DUT class generated by Picker includes a clock source `self.xclock`, as does `DUTRandomGenerator`.

Before testing, connect the `clk` pin of the module under test to the clock source using the pre-packaged method in `dut`:

```python
self.dut.init_clock("clk") # Equivalent to self.xclock.Add(self.port["clk"])
```

Then reset the generator and initialize the values:

```python
self.dut.reset.value = 1 
self.dut.Step(1)  # Wait one clock cycle, the next cycle will set dut's output to 0
self.dut.reset.value = 0  # Remember to reset the original signal after setting!
```

After initialization, add the callback functions triggered on the rising edge of the clock for verification and statistics:

```python
self.dut.StepRis(self.callback1)  # Add the callback function triggered on the rising edge of the clock
self.dut.StepRis(self.callback2)  # Multiple callbacks can be added
```

Then wait for 114514 clock cycles, during which each rising edge verifies the result and counts the random number distribution:

```python
self.dut.Step(114514)
```

Finally, complete the process and call `median_distribution_stats` to output the random number distribution:

```python
self.dut.finalize()
callback3(self.greater, self.less_equal, self.MEDIAN)
```

The test is now complete.

#### Random Number Generator Test Code {#test_random_generator_with_callback}

```python
from UT_RandomGenerator import *
import random


def median_distribution_stats(gt, le, mid) -> None:
    # Output the count of numbers greater than and less than or equal to the median.
    print(f"There are {gt} numbers > {mid} and {le} numbers <= {mid}")

# 16-bit Linear Feedback Shift Register Simulation Class
class LFSR_16:
    def __init__(self, seed):
        self.state = seed & ((1 << 16) - 1)

    def step(self):
        new_bit = (self.state >> 15) ^ (self.state >> 14) & 1
        self.state = ((self.state << 1) | new_bit) & ((1 << 16) - 1)


class TestRandomGenerator:
    def __init__(self) -> None:
        self.MEDIAN = 2**15
        self.SEED = random.randint(0, 2**16 - 1)
        self.greater = 0
        self.less_equal = 0
        self.ref = LFSR_16(self.SEED)
        self.dut = DUTRandomGenerator()

    def test_rg(self, callback3) -> None:
        # Connect the clk pin to the clock source
        self.dut.init_clock("clk")
        self.dut.seed.value = self.SEED
        # Reset operation
        self.dut.reset.value = 1 
        self.dut.Step(1)  # Wait one clock cycle, the next cycle will set dut's output to 0
        self.dut.reset.value = 0  # Remember to reset the original signal after setting!
        # Set the callback functions
        self.dut.StepRis(self.callback1)  # Add the callback function triggered on the rising edge of the clock
        self.dut.StepRis(self.callback2)  # Multiple callbacks can be added
        # Test, start!
        self.dut.Step(114514) # Wait for 114514 clock cycles
        # End
        self.dut.finalize()
        callback3(self.greater, self.less_equal, self.MEDIAN)
        pass

    def callback1(self, clk):
        # Verify if the result matches the expectation
        assert self.dut.random_number.value == self.ref.state, "Mismatch"
        print(
            f"Cycle {clk}, DUT: {self.dut.random_number.value:x},"
            + f" REF: {self.ref.state:x}"
        )
        self.ref.step()

    def callback2(self, clk):
        # Count the distribution of generated random numbers greater than and less than or equal to the median
        if self.dut.random_number.value > self.MEDIAN:
            self.greater += 1
        else:
            self.less_equal += 1


if __name__ == "__main__":
    TestRandomGenerator().test_rg(median_distribution_stats)
    pass
```


### Adding Callback Functions When Verifying the Adder

Define a 32-bit adder `RisAdder` that updates its output only on the rising edge of the clock. The RTL code is:

```verilog
module RisAdder #(
    parameter WIDTH = 32
) (
	input              clk,
	input  [WIDTH-1:0] a,
    input  [WIDTH-1:0] b,
    input              cin,
    output [WIDTH-1:0] sum,
    output             cout
);
reg Cout;
reg [WIDTH-1:0] Sum;

always @(posedge clk) begin
	{Cout, Sum} <= a + b + cin;
end
  
assign {cout, sum} = {Cout, Sum};

endmodule
```

In the following [test code](#test_ris_adder_with_callback), we will use a callback function in the adder test.

Before the test begins, create an instance `dut` of the `DUTRisAdder` class and an instance ref of the `SimpleRisAdder` class. The `ref` object simulates the expected behavior of the adder as a reference adder.

The DUT class generated by Picker will include a clock source `self.xclock` for the driving circuit, and `DUTRisAdder` is no exception.

Before the test starts, connect the `clk` pin of the device under test to the clock source:

```python3
dut.init_clock("clk") # Equivalent to self.xclock.Add(self.port[name])
```

Set the input of the adder to 0 so that its output will be 0 in the next cycle:

```python
dut.a.value = 0
dut.b.value = 0
dut.cin.value = 0
dut.Step(1) # Wait for the clock to enter the next cycle
```
Next, add a callback function `test_adder(clk: int, dut: DUTRisAdder, ref: SimpleRisAdder) -> None`, and pass the `dut` and `ref` objects to `test_adder`:

```python
# Test function to verify the correctness of the adder output
def test_adder(clk: int, dut: DUTRisAdder, ref: SimpleRisAdder) -> None:
    # Get the inputs and outputs of the adder
    a = dut.a.value
    b = dut.b.value
    cin = dut.cin.value
    cout = dut.cout.value
    sum = dut.sum.value

    # Check if the output of the adder matches the expected result
    isEqual = (cout, sum) == (ref.cout, ref.sum)

    # Print test results
    print(f"Cycle: {clk}, Input(a, b, cin) = ({a:x}, {b:x}, {cin:x})")
    print(
        FONT_GREEN + "Pass."  # Print "Pass." in green if the test passes
        if isEqual
        else FONT_RED + f"MisMatch! Expect cout: {ref.cout:x}, sum: {ref.sum:x}." +
        FONT_COLOR_RESET + f"Get cout: {cout:x}, sum: {sum:x}."
    )
    assert isEqual  # Trigger an assertion error if the test fails


if __name__ == "__main__":
    ...
    dut.StepRis(test_adder, (dut, ref))  # Add a callback function triggered on the rising edge of the clock, passing the dut and ref objects to the callback function
   	...
```

The `test_adder` function will compare the outputs of `dut` and `ref` at the rising edge of the clock to verify if the RTL code implementation meets our expectations.

Finally, the test will run for 114,514 cycles, with each test data signal lasting for one cycle:

```python
# Test for 114,514 cycles
for _ in range(114514):
	a = random.randint(0, (1<<WIDTH) - 1)
	b = random.randint(0, (1<<WIDTH) - 1)
	cin = random.randint(0, 1)
	dut.a.value = a
	dut.b.value = b
	dut.cin.value = cin
	ref.step(a, b, cin) # Update the reference adder's state
	dut.Step(1) # Wait for the clock to enter the next cycle

dut.finalize()
```

#### Code for Adder Updated on Rising Edge {#test_ris_adder_with_callback}

```python
from UT_RisAdder import *
import random

# Font color control
FONT_GREEN = "\033[0;32m"
FONT_RED = "\033[0;31m"
FONT_COLOR_RESET = "\033[0m"

class SimpleRisAdder:
    """
    SimpleRisAdder class acts as a reference adder,
    simulating the expected behavior of our RisAdder 
    """
    def __init__(self, width) -> None:
        self.WIDTH = width  # Adder width
        # Port definitions
        self.a = 0  # Input port a
        self.b = 0  # Input port b
        self.cin = 0  # Input port cin
        self.cout = 0  # Output port cout
        self.sum = 0   # Output port sum

    def step(self, a, b, cin):
        """
        Simulate the output update on the rising edge: first update the output with the input from the last cycle, then update the input
        """
        sum = self.a + self.b + self.cin
        self.cout = sum >> self.WIDTH  # Calculate carry-out
        self.sum = sum & ((1 << self.WIDTH) - 1)  # Calculate sum

        self.a = a  # Update input a
        self.b = b  # Update input b
        self.cin = cin  # Update input cin        


# Test function to verify if the adder's output is correct
def test_adder(clk: int, dut: DUTRisAdder, ref: SimpleRisAdder) -> None:
    # Get adder inputs and outputs
    a = dut.a.value
    b = dut.b.value
    cin = dut.cin.value
    cout = dut.cout.value
    sum = dut.sum.value

    # Verify if the output meets expectations
    isEqual = (cout, sum) == (ref.cout, ref.sum)

    # Output test result
    print(f"Cycle: {clk}, Input(a, b, cin) = ({a:x}, {b:x}, {cin:x})")
    print(
        FONT_GREEN + "Pass."
        if isEqual
        else FONT_RED + f"MisMatch! Expect cout: {ref.cout:x}, sum: {ref.sum:x}.",
        FONT_COLOR_RESET + f"Get cout: {cout:x}, sum: {sum:x}.",
    )
    assert isEqual # Trigger an assertion error if the test fails


if __name__ == "__main__":
    WIDTH = 32  # Set adder width
    ref = SimpleRisAdder(WIDTH)  # Create a reference adder
    dut = DUTRisAdder()  # Create the adder under test
    # Bind clock signal
    dut.init_clock("clk") # Equivalent to self.xclock.Add(self.port[name])
    # Initialize dut input signals to 0
    dut.a.value = 0
    dut.b.value = 0
    dut.cin.value = 0
    dut.Step(1) # Wait for the clock to enter the next cycle
    dut.StepRis(test_adder, (dut, ref)) # Add a callback function triggered on the rising edge of the clock, passing dut and ref to the callback
    # Test for 114,514 cycles
    for _ in range(114514):
        # Generate random inputs
        a = random.randint(0, (1<<WIDTH) - 1)
        b = random.randint(0, (1<<WIDTH) - 1)
        cin = random.randint(0, 1)
        ref.step(a, b, cin) # Update the reference adder's state
        dut.a.value = a  # Set input a of the adder under test
        dut.b.value = b  # Set input b of the adder under test
        dut.cin.value = cin  # Set input cin of the adder under test
        dut.Step(1) # Wait for the clock to enter the next cycle

    dut.finalize()
    pass
```

## Eventloop
### Overview
>**Event Loop：**The event loop mechanism is a programming model that allows a program to wait for events (such as `input, timers, network events`) to occur in a non-blocking manner. It is used to wait for and distribute messages and events, running in a single-threaded way without blocking. The core of the **event loop** mechanism is the event loop itself, where the program continuously polls the event queue for pending events and executes corresponding **callback functions** to handle them. The program can achieve **asynchronous, non-blocking** programming, improving responsiveness and efficiency.

### Basic Principles
The workflow of an event loop typically follows these steps:

1. Start the program and execute synchronous code until asynchronous code is encountered.
2. Place the callback functions of asynchronous code into the event queue to be executed when the event occurs.
3. After all synchronous code has been executed, start the event loop and continuously check for events.
4. If the event queue is not empty, execute the associated callback functions.
5. Return to step 4 and continue looping to handle events.
In pseudo-code form:
```
while(1) {
  events = getEvents();
  for (e in events)
    processEvent(e);
}
```

### Event Loop in Python
The asyncio module in Python provides the following methods to manage the event loop:

1. loop = get_event_loop(): Get the current event loop.
2. asyncio.set_event_loop(): Set the event loop for the current context.
3. asyncio.new_event_loop(): Create a new event loop based on this policy and return it.
4. loop.call_at(): Run at a specified time.
5. loop.call_later(delay, callback, arg): Execute the callback method after a delay of delay seconds.
6. loop.call_soon(callback, argument): Call the callback method as soon as possible; after the call to call_soon() ends and the main thread returns to the event loop, callback will be called immediately.
7. loop.time(): Return the internal time of the current event loop.
8. loop.run_forever(): Run until stop() is called.

In the following example, we define a callback method to print the parameters and the internal time of the loop to observe the order of function definition and execution:

- In the main method, first, we get the current event loop loop and the current time.
- Then, we call the callback method in order, setting different start times for execution.

```python
import asyncio

def callback(a, loop):
    print("My parameter is {0}，executed at time {1}".format(a,loop.time()))

if __name__ == "__main__":
    try:
        loop = asyncio.get_event_loop()
        now = loop.time()
        loop.call_later(5, callback, 5, loop)
        loop.call_at(now+2, callback, 2, loop)
        loop.call_at(now+1, callback, 1, loop)
        loop.call_at(now+3, callback, 3, loop)
        loop.call_soon(callback, 4, loop)
        loop.run_forever()  #Use this to run run_forever
    except KeyboardInterrupt:
        print("Goodbye!")

```

The output will be:
```
My parameter is 4, executed at time 266419.843
My parameter is 1, executed at time 266420.843
My parameter is 2, executed at time 266421.859
My parameter is 3, executed at time 266422.859
My parameter is 5, executed at time 266424.843
```

### Drawbacks of Callback Functions and Event Loop
Despite the advantages, callback functions have some drawbacks, leading to the introduction of the asynchronous concept in the next section. Drawbacks include:
1. Excessive Nesting: Too many nested callback functions make the code difficult to maintain.
2. Race Conditions: If there are shared resources accessed within the callback functions, race conditions can easily occur, causing program errors.
3. Poor Readability: The use of callback functions may disrupt the structure and readability of the code, especially when handling large amounts of data.
